# 如何将物品的二进制数据转换成可读字符串

## 示例物品代码

```
示例#1，非元素武器
@UgxFw!2}TYgjNc48i7M2hN}^_>Vxm5E1~mtj2XzXS3Y7~L4s{O!
22, 0, 1, 50| 2, 3262|| {67} {2} {5} {66} {73} {72} {15} {19} {25} {28} {35} {36} {44} {48} {59}|
00100 00 100 0110110000 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 011111101100110 00 00 101 1100100100 010 101 01000 010 101 10100 010 101 0100100100 010 101 1001100100 010 101 0001100100 010 101 11110 010 101 1100110000 010 101 1001110000 010 101 0011110000 010 101 1100101000 010 101 0010101000 010 101 0011101000 010 101 0000111000 010 101 1101111000 010 00 0000
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             22         ,      0     ,      1     ,      50         |      2     ,      3262            |  |      67                 2             5             66                 73                 72                 15            19                 25                 28                 35                 36                 44                 48                 59
```
```
示例#2，元素武器，被回购
@UgdhV<Fme!O0ue@92CYLCDp8FZHk1xk6LqOi-9*hng+h%&y+VaU{X_r
8, 0, 1, 50| 10, 1| 2, 3170|| {53} {2} {4} {6} {1:13} {52} {74} {11} {15} {75} {25} {32} {33} {39} {48} {79}|
00100 00 100 00010 01 100 00000 01 100 10000 01 100 0100111000 00 100 01010 01 100 10000 00 100 01000 01 100 010010110100110 00 00 101 1010111000 010 101 01000 010 101 00100 010 101 01100 010 101 10000 1 10110 000 101 0010111000 010 101 0101100100 010 101 11010 010 101 11110 010 101 1101100100 010 101 1001110000 010 101 0000101000 010 101 1000101000 010 101 1110101000 010 101 0000111000 010 101 1111100100 010 00 000000
             ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑   ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             8     ,      0     ,      1     ,      50         |      10           1     |      2            3170            |  |      53                 2             4             6             1     : 13            52                 74                 11            15            75                 25                 32                 33                 39                 48                 79
```
```
示例#3，强化
@Ugr%1Tm/)}}!qhvUNWCv7Xi/fEAI%M^D+d4
303, 0, 1, 50| 2,  885|| {8} {247:76} {9} {1} {247:[23 181 7]}|
00100 00 110 10010 111101001 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 101011110111000 00 00 101 00010 010 101 1110111110 1 0011100100 000 101 10010 010 101 10000 010 101 1110111110 0 0101 100 1110110000 100 1010111010 100 11100 000 00 000000
             ↑↑↑↑↑ ↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑   ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑  →|
             9len  303       ,      0     ,      1     ,      50         |      2            885             |  |      8             247        : 76                 9             1             247          :        23             181            7
```

```
示例#4，职业模组
@Ug!pHG2}TZ*Od!Hk{GfKIO!YFT-3FEGpl%;j?$j-VsvQj+$sw}<
254, 0, 1, 50| 9, 1| 2, 3973|| {54} {12} {302} {365} {428} {491} {236} {299} {234:[48 25 83]}|
00100 00 100 0111111110 01 100 00000 01 100 10000 01 100 0100111000 00 100 10010 01 100 10000 00 100 01000 01 100 101010001111110 00 00 101 0110111000 010 101 00110 010 101 011110100110000 010 101 101110110110000 010 101 001110101110000 010 101 110110111110000 010 101 0011101110 010 101 110110100110000 010 101 0101101110 0 0101 100 0000111000 100 1001110000 100 1100110100 000 00 0
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑  →|
             254        ,      0     ,      1     ,      50         |      9     ,      1     |      2     ,      3972            |  |      54                 12            302                     365                     428                     491                     236                299                     234          :        48             25             83                
```

## 解读

1. 读取5个bit，值固定为`00100`，表示物品数据起始标志
2. 读取2个bit，读取到`00`，表示这个一个数据片段的开始
3. 读取3个bit，有两个取值（可能更多）：
   - `100` 表示后续bit按照`varint5`编码（示例#1#2#4）
   - `110` 表示后续bit按照`varbit5`编码（示例#3）
4. 按照`varint5`/`varbit5`规范读取一组数据，该数据代表厂家和物品类型，在示例#1中，这个值是`22`
5. 读取2个bit，读取到`01`，表示后续bit是同一个片段内的其他数据，是一个片段内数据的分割符
6. 重复步骤3~5，直到第5步读取到`00`，表示一个片段读取结束，在示例#1中，此时读取到的数据为`22, 0, 1, 50`，其中50为物品等级
7. 尝试读取2个bit
   - 如果是`00`，意味着读取到了连续2个`00`，此时表示后续数据是配件数据，需要改变读取策略（步骤8）
   - 如果不是`00`，则改为读取3个bit，并重复3-5步骤，直到再次读取到`00`，在示例#1中，此时读取到的数据为`22, 0, 1, 50| 2，3262||`
8. 当读取到了连续2个`00`时，表示后续数据是配件数据
   1. 读取3个bit，固定应为`101`，表示配件数据开始，据目前了解，配件数据总是遵循`varint5`编码规范
   2. 按照`varint5`规范读取一组数据，在示例#1中，第一次遇到的这个值是`67`
   3. 接着读取1个bit，如果：
      1. 读取到`1`，则表示后续bit是个对象数据，后续bit遵循`varint5`规范编码。接着读取3个bit，理应为`000`，表示该数据结束
      2. 读取到`0`，则应继续读取2个bit，如果：
         - 读取到`10`，此时，读取到的3个bit为`010`时，表示该数据结束
         - 读取到`01`，则应继续读取2个bit，理应为`01`，此时读取到的共5个bit为`00101`，表示后续bit是数组数据，包含多个数值，每个数值包含3个bit的前缀和`varint5`/`varbit5`数据（和步骤3~5的读取方法类似），当读取到`000`时，表示该数据结束
  1. 重复步骤8.1~8.3，直到读取完全部数据
9. 读取完毕

## 总结

- `00100`：是物品数据标志
- `00`：是数据片段分割符
- `0000`：连续2个`00`，是物品头数据和配件数据的分割符
- `100`、`110`：是数据编码方式，`100`=`varint5`，`110`=`varbit5`
- `01`：是片段内数据分割符
- `101` xxxxx `010`：表示一个配件，该配件用单个值表示
- `101` xxxxx 1 xxxxx `000`：表示一个配件，该配件用对象值表示
- `101` xxxxx 0 0101 100 xxxxx `000`：表示一个配件，该配件用数组值表示



# How to Convert Item Binary Data into Human-Readable Strings

## Example Item Codes

```
Example #1, Non-elemental Weapon
@UgxFw!2}TYgjNc48i7M2hN}^_>Vxm5E1~mtj2XzXS3Y7~L4s{O!
22, 0, 1, 50| 2, 3262|| {67} {2} {5} {66} {73} {72} {15} {19} {25} {28} {35} {36} {44} {48} {59}|
00100 00 100 0110110000 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 011111101100110 00 00 101 1100100100 010 101 01000 010 101 10100 010 101 0100100100 010 101 1001100100 010 101 0001100100 010 101 11110 010 101 1100110000 010 101 1001110000 010 101 0011110000 010 101 1100101000 010 101 0010101000 010 101 0011101000 010 101 0000111000 010 101 1101111000 010 00 0000
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             22         ,      0     ,      1     ,      50         |      2     ,      3262            |  |      67                 2             5             66                 73                 72                 15            19                 25                 28                 35                 36                 44                 48                 59
```
```
Example #2, Elemental Weapon, Buyback
@UgdhV<Fme!O0ue@92CYLCDp8FZHk1xk6LqOi-9*hng+h%&y+VaU{X_r
8, 0, 1, 50| 10, 1| 2, 3170|| {53} {2} {4} {6} {1:13} {52} {74} {11} {15} {75} {25} {32} {33} {39} {48} {79}|
00100 00 100 00010 01 100 00000 01 100 10000 01 100 0100111000 00 100 01010 01 100 10000 00 100 01000 01 100 010010110100110 00 00 101 1010111000 010 101 01000 010 101 00100 010 101 01100 010 101 10000 1 10110 000 101 0010111000 010 101 0101100100 010 101 11010 010 101 11110 010 101 1101100100 010 101 1001110000 010 101 0000101000 010 101 1000101000 010 101 1110101000 010 101 0000111000 010 101 1111100100 010 00 000000
             ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑   ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             8     ,      0     ,      1     ,      50         |      10           1     |      2            3170            |  |      53                 2             4             6             1     : 13            52                 74                 11            15            75                 25                 32                 33                 39                 48                 79
```
```
Example #3, Enhancement
@Ugr%1Tm/)}}!qhvUNWCv7Xi/fEAI%M^D+d4
303, 0, 1, 50| 2,  885|| {8} {247:76} {9} {1} {247:[23 181 7]}|
00100 00 110 10010 111101001 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 101011110111000 00 00 101 00010 010 101 1110111110 1 0011100100 000 101 10010 010 101 10000 010 101 1110111110 0 0101 100 1110110000 100 1010111010 100 11100 000 00 000000
             ↑↑↑↑↑ ↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑   ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑  →|
             9len  303       ,      0     ,      1     ,      50         |      2            885             |  |      8             247        : 76                 9             1             247          :        23             181            7
```

```
Example #4, Class Mod
@Ug!pHG2}TZ*Od!Hk{GfKIO!YFT-3FEGpl%;j?$j-VsvQj+$sw}<
254, 0, 1, 50| 9, 1| 2, 3973|| {54} {12} {302} {365} {428} {491} {236} {299} {234:[48 25 83]}|
00100 00 100 0111111110 01 100 00000 01 100 10000 01 100 0100111000 00 100 10010 01 100 10000 00 100 01000 01 100 101010001111110 00 00 101 0110111000 010 101 00110 010 101 011110100110000 010 101 101110110110000 010 101 001110101110000 010 101 110110111110000 010 101 0011101110 010 101 110110100110000 010 101 0101101110 0 0101 100 0000111000 100 1001110000 100 1100110100 000 00 0
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑  →|
             254        ,      0     ,      1     ,      50         |      9     ,      1     |      2     ,      3972            |  |      54                 12            302                     365                     428                     491                     236                299                     234          :        48             25             83                
```
## Interpretation

1. **Read 5 bits** with the fixed value `00100`, indicating the start of item data.
2. **Read 2 bits**. If `00` is read, it marks the beginning of a data segment.
3. **Read 3 bits**. There are (at least) two possible values:
   - `100` indicates that subsequent bits are encoded using the **`varint5`** format (Examples #1, #2, #4).
   - `110` indicates that subsequent bits are encoded using the **`varbit5`** format (Example #3).
4. **Read a set of data** following the `varint5`/`varbit5` specification. This data represents the manufacturer and item type. In Example #1, this value is `22`.
5. **Read 2 bits**. If `01` is read, it indicates that the following bits contain other data within the *same segment*, acting as an **intra-segment data separator**.
6. **Repeat steps 3–5** until `00` is read in Step 5, which signifies the **end of the current segment**. In Example #1, the data read up to this point is `22, 0, 1, 50`, where `50` is the item level.
7. **Attempt to read 2 bits:**
   - If `00` is read (meaning **two consecutive `00`s** have been encountered), it indicates that the subsequent data contains **component/parts data**, and the reading strategy must change (proceed to Step 8).
   - If not `00`, then **read 3 bits** and repeat Steps 3–5 until `00` is read again. In Example #1, the data read here becomes `22, 0, 1, 50| 2, 3262||`.
8. **When two consecutive `00`s are read**, signifying component data follows:
    1. **Read 3 bits**, which should be the fixed value `101`, marking the **start of component data**. Based on current understanding, component data always follows the **`varint5`** encoding specification.
    2. Read a set of data following the `varint5` specification. In Example #1, the first value encountered here is `67`.
    3. Next, **read 1 bit**:
       - If `1` is read, it indicates the subsequent bits represent **object data**, encoded with `varint5`. Then, read 3 more bits, which should be `000`, marking the **end of this object data**.
       - If `0` is read, then continue to **read 2 bits**:
         - If `10` is read, making the last 3 bits `010`, it signifies the **end of this data**.
         - If `01` is read, then continue to **read 2 more bits**, which should be `01`, making the final 5 bits read `00101`. This indicates the subsequent bits represent **array data** containing multiple values. Each value consists of a **3-bit prefix** followed by `varint5`/`varbit5` encoded data (similar to the method in Steps 3–5). Reading `000` marks the **end of this array data**.
    4. **Repeat steps 8.1–8.3** until all data has been read.
9. **Reading is complete.**

## Summary

- `00100`: Item data marker
- `00`: Data segment separator
- `0000`: Consecutive double `00` - separator between item header data and parts data
- `100`, `110`: Data encoding methods (`100` = varint5, `110` = varbit5)
- `01`: Intra-segment data separator
- `101` xxxxx `010`: Part represented by single value
- `101` xxxxx 1 xxxxx `000`: Part represented by object value
- `101` xxxxx 0 0101 100 xxxxx `000`: Part represented by array value