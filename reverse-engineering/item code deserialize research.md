# 如何将物品的二进制数据转换成可读字符串

## 示例物品代码

```
示例#1，非元素武器
@UgxFw!2}TYgjNc48i7M2hN}^_>Vxm5E1~mtj2XzXS3Y7~L4s{O!
22, 0, 1, 50| 2, 3262|| {67} {2} {5} {66} {73} {72} {15} {19} {25} {28} {35} {36} {44} {48} {59}|
00100 00 100 0110110000 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 011111101100110 00 00 101 1100100100 010 101 01000 010 101 10100 010 101 0100100100 010 101 1001100100 010 101 0001100100 010 101 11110 010 101 1100110000 010 101 1001110000 010 101 0011110000 010 101 1100101000 010 101 0010101000 010 101 0011101000 010 101 0000111000 010 101 1101111000 010 00 0000
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             22         ,      0     ,      1     ,      50         |      2     ,      3262            |  |      67                 2             5             66                 73                 72                 15            19                 25                 28                 35                 36                 44                 48                 59
```
```
示例#2，元素武器，被回购
@UgdhV<Fme!O0ue@92CYLCDp8FZHk1xk6LqOi-9*hng+h%&y+VaU{X_r
8, 0, 1, 50| 10, 1| 2, 3170|| {53} {2} {4} {6} {1:13} {52} {74} {11} {15} {75} {25} {32} {33} {39} {48} {79}|
00100 00 100 00010 01 100 00000 01 100 10000 01 100 0100111000 00 100 01010 01 100 10000 00 100 01000 01 100 010010110100110 00 00 101 1010111000 010 101 01000 010 101 00100 010 101 01100 010 101 10000 1 10110 000 101 0010111000 010 101 0101100100 010 101 11010 010 101 11110 010 101 1101100100 010 101 1001110000 010 101 0000101000 010 101 1000101000 010 101 1110101000 010 101 0000111000 010 101 1111100100 010 00 000000
             ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑   ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             8     ,      0     ,      1     ,      50         |      10           1     |      2            3170            |  |      53                 2             4             6             1     : 13            52                 74                 11            15            75                 25                 32                 33                 39                 48                 79
```
```
示例#3，强化
@Ugr%1Tm/)}}!qhvUNWCv7Xi/fEAI%M^D+d4
303, 0, 1, 50| 2,  885|| {8} {247:76} {9} {1} {247:[23 181 7]}|
00100 00 110 10010 111101001 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 101011110111000 00 00 101 00010 010 101 1110111110 1 0011100100 000 101 10010 010 101 10000 010 101 1110111110 0 0101 100 1110110000 100 1010111010 100 11100 00 00 0000000
             ↑↑↑↑↑ ↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑   ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑ →|
             9len  303       ,      0     ,      1     ,      50         |      2            885             |  |      8             247        : 76                 9             1             247          :        23             181            7        |
```

```
示例#4，职业模组
@Ug!pHG2}TZ*Od!Hk{GfKIO!YFT-3FEGpl%;j?$j-VsvQj+$sw}<
254, 0, 1, 50| 9, 1| 2, 3973|| {54} {12} {302} {365} {428} {491} {236} {299} {234:[48 25 83]}|
00100 00 100 0111111110 01 100 00000 01 100 10000 01 100 0100111000 00 100 10010 01 100 10000 00 100 01000 01 100 101010001111110 00 00 101 0110111000 010 101 00110 010 101 011110100110000 010 101 101110110110000 010 101 001110101110000 010 101 110110111110000 010 101 0011101110 010 101 110110100110000 010 101 0101101110 0 0101 100 0000111000 100 1001110000 100 1100110100 00 00 00
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑ →|
             254        ,      0     ,      1     ,      50         |      9     ,      1     |      2     ,      3972            |  |      54                 12            302                     365                     428                     491                     236                299                     234          :        48             25             83            |               
```

## 解读

1. 首先读取5个bit，值固定为`00100`，表示物品数据起始标志
2. 读取2个bit，理应读取到`00`，表示这是一个数据片段的开始（实际上结束也是`00`）
3. 读取3个bit，有两个取值（可能更多）：
   1. `100` 这是一个标记，表示后续bit按照`varint5`编码（示例#1#2#4）
   2. `110` 这是一个标记，表示后续bit按照`varbit5`编码（示例#3）
   3. `101` 这是一个标记，表示这是一个配件数据，后续bit也是按照`varint5`编码
   4. `111` 这是一个标记，后续是皮肤或DLC数据，我们不解析它，直接忽略
   5. 如果没有读到任何有效值（后续全为`0`），则表示读取结束
4. 按照`varint5`/`varbit5`规范读取一组数据，第一个读取到的数据代表厂家和物品类型，在示例#1中，这个值是`22`
5. 接下来有两种情况：
   1. 如果之前读取到的标记是`100`或`110`，则接着读取2个bit，如果：
      1. 读取到`01`，这是一个数据分割符，表示后面还有同类数据，继续从步骤3开始循环
      2. 读取到`00`，表示该片段已结束，继续从步骤2开始循环
   2. 如果之前读取到的标记是`101`，则接着读1个bit，如果：
      1. 读取到`1`，则表示后续bit是个对象数据，遵循`varint5`规范编码读取1个数据，然后再读取3个bit，理应是`000`，表示该数据结束
      2. 读取到`0`，则应继续读取2个bit，如果：
         1. 读取到`10`，此时，读取到的3个bit为`010`，表示该数据结束
         2. 读取到`01`，则应继续读取2个bit，有可能有两个值：
            1. 读取到`01`，这是一个标记，表示数组数据开始，继续读取数据从步骤3开始循环
            2. 读取到`00`，这是一个标记，表示数据数据结束
6.  重复循环步骤2~5，直到读取完全部数据

## 总结

- `00100`：是物品数据标志，物品数据固定以此开始，标志之后总是跟着数据片段也就是以`00`开始`00`结束的数据片段
- `00`：是数据片段分割符，两个`00`之间是一个数据片段
- `100`、`110`：是数据编码方式，`100`=`varint5`，`110`=`varbit5`
- `01`：是片段内数据分割符
- `101`：是一个配件数据的开始，后面是一段`varint5`数据
- `101` xxxxx `010`：表示一个配件，该配件用单个值表示
- `101` xxxxx 1 xxxxx `000`：表示一个配件，该配件用对象值表示
- `101` xxxxx 0 01 `01` 100 xxxxx `00`：表示一个配件，该配件用数组值表示（在初始版本中我并未检查数组出现在中间的情况，所以未发现`00`是数组数据的结尾）


# How to Convert Item Binary Data into Human-Readable Strings

## Example Item Codes

```
Example #1, Non-elemental Weapon
@UgxFw!2}TYgjNc48i7M2hN}^_>Vxm5E1~mtj2XzXS3Y7~L4s{O!
22, 0, 1, 50| 2, 3262|| {67} {2} {5} {66} {73} {72} {15} {19} {25} {28} {35} {36} {44} {48} {59}|
00100 00 100 0110110000 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 011111101100110 00 00 101 1100100100 010 101 01000 010 101 10100 010 101 0100100100 010 101 1001100100 010 101 0001100100 010 101 11110 010 101 1100110000 010 101 1001110000 010 101 0011110000 010 101 1100101000 010 101 0010101000 010 101 0011101000 010 101 0000111000 010 101 1101111000 010 00 0000
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             22         ,      0     ,      1     ,      50         |      2     ,      3262            |  |      67                 2             5             66                 73                 72                 15            19                 25                 28                 35                 36                 44                 48                 59
```
```
Example #2, Elemental Weapon, Buyback
@UgdhV<Fme!O0ue@92CYLCDp8FZHk1xk6LqOi-9*hng+h%&y+VaU{X_r
8, 0, 1, 50| 10, 1| 2, 3170|| {53} {2} {4} {6} {1:13} {52} {74} {11} {15} {75} {25} {32} {33} {39} {48} {79}|
00100 00 100 00010 01 100 00000 01 100 10000 01 100 0100111000 00 100 01010 01 100 10000 00 100 01000 01 100 010010110100110 00 00 101 1010111000 010 101 01000 010 101 00100 010 101 01100 010 101 10000 1 10110 000 101 0010111000 010 101 0101100100 010 101 11010 010 101 11110 010 101 1101100100 010 101 1001110000 010 101 0000101000 010 101 1000101000 010 101 1110101000 010 101 0000111000 010 101 1111100100 010 00 000000
             ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑   ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →|
             8     ,      0     ,      1     ,      50         |      10           1     |      2            3170            |  |      53                 2             4             6             1     : 13            52                 74                 11            15            75                 25                 32                 33                 39                 48                 79
```
```
Example #3, Enhancement
@Ugr%1Tm/)}}!qhvUNWCv7Xi/fEAI%M^D+d4
303, 0, 1, 50| 2,  885|| {8} {247:76} {9} {1} {247:[23 181 7]}|
00100 00 110 10010 111101001 01 100 00000 01 100 10000 01 100 0100111000 00 100 01000 01 100 101011110111000 00 00 101 00010 010 101 1110111110 1 0011100100 000 101 10010 010 101 10000 010 101 1110111110 0 0101 100 1110110000 100 1010111010 100 11100 00 00 0000000
             ↑↑↑↑↑ ↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑   ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑ →|
             9len  303       ,      0     ,      1     ,      50         |      2            885             |  |      8             247        : 76                 9             1             247          :        23             181            7        |
```

```
Example #4, Class Mod
@Ug!pHG2}TZ*Od!Hk{GfKIO!YFT-3FEGpl%;j?$j-VsvQj+$sw}<
254, 0, 1, 50| 9, 1| 2, 3973|| {54} {12} {302} {365} {428} {491} {236} {299} {234:[48 25 83]}|
00100 00 100 0111111110 01 100 00000 01 100 10000 01 100 0100111000 00 100 10010 01 100 10000 00 100 01000 01 100 101010001111110 00 00 101 0110111000 010 101 00110 010 101 011110100110000 010 101 101110110110000 010 101 001110101110000 010 101 110110111110000 010 101 0011101110 010 101 110110100110000 010 101 0101101110 0 0101 100 0000111000 100 1001110000 100 1100110100 00 00 00
             ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑       |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑  →| |←  ↑↑↑↑↑↑↑↑↑↑            ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑     ↑↑↑↑↑↑↑↑↑↑ →|
             254        ,      0     ,      1     ,      50         |      9     ,      1     |      2     ,      3972            |  |      54                 12            302                     365                     428                     491                     236                299                     234          :        48             25             83            |         
```

## How It Works

1. **First, read 5 bits** - this should always be `00100`, which is the item data start marker
2. **Read 2 bits** - you should get `00`, marking the start of a data segment (turns out it marks the end too)
3. **Read 3 bits** - there are a few possibilities here:
   - `100` = this means the following bits use `varint5` encoding (examples #1, #2, #4)
   - `110` = this means the following bits use `varbit5` encoding (example #3)  
   - `101` = this marks attachment data, also using `varint5` encoding
   - If you don't get any valid value (all remaining bits are `0`), you're done reading
4. **Read data** using `varint5`/`varbit5` rules - the first value you get is the manufacturer and item type (like `22` in example #1)
5. **Now there are two paths**:
   - If you got `100` or `110` earlier, read 2 more bits:
     - `01` = data separator, means there's more data coming - go back to step 3
     - `00` = segment ended - go back to step 2
   - If you got `101` earlier, read 1 more bit:
     - `1` = object data coming up - read one `varint5` value, then 3 bits (should be `000`) to mark the end
     - `0` = read 2 more bits:
       - `10` = together with the previous bit makes `010`, meaning single value attachment
       - `01` = read 2 more bits:
         - `01` = marks array data starting - go read data from step 3
         - `00` = marks data ending
6. **Repeat steps 2-5** until you've read all the data

## The Gist

- `00100` = item data flag, always starts with this, followed by data segments between `00` markers
- `00` = data segment separator (between two `00`s is one segment)
- `100`, `110` = data encoding types (`100` = `varint5`, `110` = `varbit5`)
- `01` = separator within a segment
- `101` = attachment data starting, followed by `varint5` data
- `101` xxxxx `010` = single value attachment
- `101` xxxxx 1 xxxxx `000` = object value attachment
- `101` xxxxx 0 01 `01` 100 xxxxx `00` = array value attachment (in the initial version I didn't check for arrays in the middle, so I missed that `00` marks the end of array data)